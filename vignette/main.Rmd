---
title: "Same Cue vs Semantic Associate Retrieval Practice"
author: "William Hopper"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.width = 9,
                      cache = TRUE)
options(mc.cores = parallel::detectCores())
library(dplyr)
library(stringdist)
library(tibble)
library(ggplot2)
library(tidyr)
library(whoppeR)
library(afex)
library(bindrcpp)
library(rstanarm)
source("../R/test_tidying.R")
```

```{r reading}
oldwd <- setwd("../data-raw")

# Lists/condition assignment table
conditions <-  read.csv("lists.csv", stringsAsFactors = FALSE) %>%
  rename(practice_cue_type = cue_type) %>%
  mutate(practice_cue_type = replace(practice_cue_type,
                                     which(practice == "N"),
                                     NA_character_))

## Group assignment table
subjects <- read.csv("participants.csv", stringsAsFactors = FALSE)

column_types <- c("integer","integer","integer", "integer", "integer",
                  "character", "character", "numeric", "integer", "numeric",
                  "numeric", "numeric", "numeric", "character")
# Test Practice
test_practice_raw <- read.csv("test_practice.csv", stringsAsFactors = FALSE,
                              na.strings = "", colClasses = column_types) %>%
  mutate(recalled = as.logical(recalled))

# Final Test
final_test_raw <- read.csv("final_test.csv", stringsAsFactors = FALSE,
                           na.strings = "", colClasses = column_types) %>%
  mutate(recalled = as.logical(recalled))

setwd(oldwd)

rm(column_types)
```

```{r tidying}
join_variables <- c("subject", "id", "list")
select_variables <- c(join_variables, "practice", "practice_cue_type")

# Remove subjects with technical problems from the dataset.
subjects <- filter(subjects, subject >= 1)

## Practice Test
test_practice_raw <- test_practice_raw %>%
  inner_join(x = .,
             y = subjects[c("subject","group")],
             by = "subject") %>%
  left_join(x = .,
            y = conditions[select_variables],
            by = join_variables) %>%
  test_tidying()

# Check these fuzzy matches by hand
tp_fuzzy <- filter(tibble::rownames_to_column(test_practice_raw, "row"),
                   !hard_match & fuzzy_match) %>%
   select(row, subject, cue, target, response)


# Final Test
final_test_raw <- final_test_raw %>%
  inner_join(x = .,
             y = subjects[c("subject","group")],
             by = "subject") %>%
  left_join(x = .,
            y = conditions[select_variables],
            by = join_variables) %>%
  test_tidying()

# Check these fuzzy matches by hand
final_fuzzy <- filter(tibble::rownames_to_column(final_test_raw, "row"),
                      !hard_match & fuzzy_match) %>%
   select(row, subject, cue, target, response)

# These are determined by manual inspection
final_test_raw[final_test_raw$subject == 21 & final_test_raw$cue == "comedy",
               'fuzzy_match'] <- FALSE

## Combine practice and final tests into one data frame
tests_raw <- bind_rows(`1`=test_practice_raw, `2`=final_test_raw,
                       .id = "test") %>%
  rename(correct = fuzzy_match) %>%
  mutate(logRT = log(RT),
         test = as.numeric(test)) %>%
  select(subject, group, test, list, trial, practice, practice_cue_type, decided, recalled,
         correct, RT, logRT, pre_typing_lag:post_typing_lag) %>%
  arrange(subject, test, list)

# Remove trials where a remember/don't remember decision was not reached, and trial timed out.
tests_raw <- filter(tests_raw, decided)

rm(tp_fuzzy, final_fuzzy, join_variables, select_variables)
```

```{r aggregating_by_subject}
#### Aggregate reaction time measures for each subject in each condition
RT_by_subject <- tests_raw %>%
  group_by(subject, group, test, practice, practice_cue_type, correct) %>%
  filter(!is.na(RT)) %>%
  summarise(N_RT_trials = n(),
            mean_RT = mean(RT),
            mean_logRT = mean(logRT),
            median_RT = median(RT)) %>%
  ungroup()

#### Calculate accuracy for each subject in each condition
acc_by_subject <- tests_raw %>%
  group_by(subject, group, test, practice, practice_cue_type) %>%
  summarise(N_acc_trials = n(),
            N_correct = sum(correct),
            percent_correct = N_correct/N_acc_trials) %>%
  ungroup()

#### Calculate the RT difference from baseline on final test
tmp <- RT_by_subject %>%
  filter(test == 2) %>%
  select(-test, -N_RT_trials) %>%
  gather(key="var", value="value", mean_RT, median_RT, mean_logRT) %>%
  unite(var, practice, var, sep=".") %>%
  spread(var, value)

control <- filter(tmp, is.na(practice_cue_type)) %>%
  select(subject, correct, starts_with("N"))
treatment <- filter(tmp, !is.na(practice_cue_type))%>%
  select(-starts_with("N"))

RT_diff_by_subject <- left_join(treatment, control, 
                                by=c("subject", "correct")) %>%
  mutate(SN.median_RT = S.median_RT - N.median_RT,
         TN.median_RT = T.median_RT - N.median_RT,
         SN.mean_logRT = S.mean_logRT - N.mean_logRT,
         TN.mean_logRT = T.mean_logRT - N.mean_logRT,
         SN.mean_RT = S.mean_RT - N.mean_RT,
         TN.mean_RT = T.mean_RT - N.mean_RT) %>%
  select(subject, group, practice_cue_type, correct,
         SN.median_RT, TN.median_RT,
         SN.mean_logRT, TN.mean_logRT,
         SN.mean_RT, TN.mean_RT) %>%
  gather(key="var", value="value", -(subject:correct)) %>%
  separate(var, into = c("practice", "var"),sep = "\\.") %>%
  spread(var,value) %>%
  mutate(practice = paste(substr(practice, 1, 1),
                          substr(practice, 2, 2),
                          sep = "-"))


#### Calculate the accuracy difference from baseline on final test
tmp <- acc_by_subject %>%
  filter(test == 2) %>%
  select(subject:practice_cue_type, percent_correct, -test) %>%
  gather(key="var", value="value", percent_correct) %>%
  unite(var, practice, var, sep=".") %>%
  spread(var, value)

control <- filter(tmp, is.na(practice_cue_type)) %>%
  select(subject, starts_with("N"))
treatment <- filter(tmp, !is.na(practice_cue_type))%>%
  select(-starts_with("N"))

acc_diff_by_subject <- left_join(treatment, control, 
                                by=c("subject")) %>%
  mutate(SN.percent_correct = S.percent_correct - N.percent_correct,
         TN.percent_correct = T.percent_correct - N.percent_correct) %>%
  select(subject, group, practice_cue_type, SN.percent_correct, TN.percent_correct) %>%
  gather(key="var", value="value", SN.percent_correct, TN.percent_correct) %>%
  separate(var, into = c("practice", "var"),sep = "\\.") %>%
  spread(var,value) %>%
  mutate(practice = paste(substr(practice, 1, 1),
                          substr(practice, 2, 2),
                          sep = "-"))
```

```{r aggregating_over_subjects}
acc <- filter(acc_by_subject, test == 2) %>%
  mutate(condition = replace(as.character(interaction(practice, practice_cue_type)),
                             is.na(practice_cue_type),
                             "N")
         ) %>%
  whoppeR::WISEsummary(dependentvars = "percent_correct", idvar = "subject",
                       betweenvars = "group", withinvars = "condition"
                       ) %>%
  rename(percent_correct = percent_correct_mean)
```

```{r}
color_scale <- scale_color_discrete("Practice\nCondition",
                                    labels = c("S.episodic" = "Restudy, Episodic",
                                               "T.episodic" = "Test, Episodic",
                                               "S.semantic" = "Restudy, Semantic",
                                               "T.semantic" = "Test, Semantic",
                                               "N" = "No Practice")
                                    )
x_axis_scale <- scale_x_discrete("Group",
                                 limits = c("immediate","delay"),
                                 labels = c("Immediate", "Delay"),
                                 expand = c(0, .1)
                                 )
```

```{r plot_group_averages}
acc_plot <- mutate(acc, condition = factor(condition,
                                           levels = c("S.episodic","S.semantic","T.semantic","T.episodic","N")
                                           )
                   ) %>%
  ggplot(aes(x = group, y = percent_correct,
             color = condition, group = condition
             )
         ) +
  geom_point(size = 2, position = position_dodge(.1)) +
  geom_line(position = position_dodge(.1)) +
  geom_errorbar(aes(ymin = percent_correct_CI_lower, ymax = percent_correct_CI_upper),
                width = .15,
                position = position_dodge(.1)) +
  x_axis_scale +
  scale_y_continuous("Percent Correct", limits = c(.2, .8),
                     breaks = seq(.2, .8, by = .1)) + 
  color_scale +
  theme_grey(base_size = 16)

print(acc_plot)
```

```{r acc_glmer}
afex::set_sum_contrasts()

# This function absolutely relies on hard-coding the order of the factor levels in the regressions anlysis. If the factors are for some reason ordered in some other fashion than described in the row names here, these contrasts will not match their labels!

my_contrasts.emmc <- function(...) {
  custom_contrast_matrix <- data.frame(`S.semantic - S.episodic` = c(-1, 1, 0, 0, 0),
                                       `T.semantic - S.semantic` = c(0, -1, 1, 0, 0),
                                       `T.episodic - T.semantic` = c(0, 0, -1, 1, 0),
                                       `T.episodic - S.episodic` = c(-1, 0, 0, 1, 0),
                                       `N - T.episodic` =          c(0, 0, 0, -1, 1),
                                       `N - T.semantic` =          c(0, 0, -1, 0, 1),
                                       `N - S.semantic` =          c(0, -1, 0, 0, 1),
                                       `N - S.episodic` =          c(-1, 0, 0, 0, 1),
                                       row.names = c("S.episodic","S.semantic","T.semantic","T.episodic","N"),
                                       check.names = FALSE
                                       )
  return(custom_contrast_matrix)
}
acc_data <- mutate(tests_raw,
                   condition = replace(as.character(interaction(practice, practice_cue_type)),
                                       is.na(practice_cue_type),
                                       "N"),
                   condition = factor(condition,
                                      levels = c("S.episodic","S.semantic","T.semantic","T.episodic","N")
                                      ),
                   group = factor(group, levels = c("immediate","delay"))) %>%
  filter(test == 2)

PSOCK_cl <- parallel::makeCluster(parallel::detectCores())

acc_glmer <- mixed(correct ~ group*condition + (1|subject),
                   data = acc_data,
                   method = "LRT",
                   cl = PSOCK_cl,
                   family = binomial,
                   progress = TRUE
                   )

parallel::stopCluster(PSOCK_cl)
summary(acc_glmer$full_model)

acc_emm <- emmeans(acc_glmer, specs = c("group", "condition"), type = "response")
acc_contrasts <- summary(contrast(acc_emm, method = my_contrasts.emmc, by ="group",
                                  type ="link", adjust = 'holm')
                         )
acc_contrast_s2 <- summary(contrast(acc_emm, method = 'pairwise', by ="group",
                                  type ="link", adjust = 'holm')
                         )
knitr::kable(nice(acc_glmer), format = 'html') %>%
  kableExtra::kable_styling(full_width = FALSE, position = 'float_left')

select(as.data.frame(acc_contrasts), group, contrast, estimate:p.value) %>%
knitr::kable(format = 'html', align = 'crccccc', digits = c(0,0,3,3,3,3,4),
             caption = paste(attr(acc_contrasts,"mesg"), collapse = ". ")) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::collapse_rows(columns = 1)
```

```{r rstan_acc_glmer}
acc_glmer_uninformed <- stan_glmer(correct ~ group*condition + (1|subject),
                        data = acc_data,
                        family = binomial(link = "logit"),
                        seed = 123)

acc_glmer_uninformed_EMM <- emmeans(acc_glmer_uninformed,
                                    specs = c("group", "condition"),
                                    type = "response")
acc_glmer_uninformed_EMM_plot <-
  ggplot(as.data.frame(acc_glmer_uninformed_EMM),
         aes(x = group, y = prob, color = condition, group = condition)
         ) +
  geom_point(size = 2, position = position_dodge(.1)) +
  geom_line(position = position_dodge(.1)) +
  geom_errorbar(aes(ymin = lower.HPD, ymax = upper.HPD),
                width = .15,
                position = position_dodge(.1)) +
  x_axis_scale +
  scale_y_continuous("Percent Correct", limits = c(.1, .9),
                     breaks = seq(.1, .9, by = .1)) +
  color_scale +
  theme_grey(base_size = 16)
print(acc_glmer_uninformed_EMM_plot)

acc_glmer_uninformed_contrasts <- contrast(acc_glmer_uninformed_EMM, 'my_contrasts',
                                           by = "group", type ="link")
plot(acc_glmer_uninformed_contrasts) + geom_vline(xintercept = 0)
```

```{r RT_means}
RT <- filter(RT_by_subject, test == 2, correct) %>%
  mutate(condition = replace(as.character(interaction(practice, practice_cue_type)),
                             is.na(practice_cue_type),
                             "N")
         ) %>%
  whoppeR::WISEsummary(dependentvars = c("mean_RT", "mean_logRT", "median_RT"), idvar = "subject",
                       betweenvars = "group", withinvars = "condition"
                       )
names(RT) <- gsub(pattern = "_mean$", "", names(RT))
```

```{r RT_plot}
RT_plot <- mutate(RT, condition = factor(condition,
                                         levels = c("S.episodic","S.semantic","T.semantic","T.episodic","N")
                                         )
                  ) %>%
  ggplot(aes(x = group, y = mean_logRT,
             color = condition, group = condition
             )
         ) +
  geom_point(size = 2, position = position_dodge(.1)) +
  geom_line(position = position_dodge(.1)) +
  geom_errorbar(aes(ymin = mean_logRT_CI_lower, ymax = mean_logRT_CI_upper),
                width = .15,
                position = position_dodge(.1)) +
  x_axis_scale +
  scale_y_continuous("Log RT (s)") + 
  color_scale +
  theme_grey(base_size = 16)

print(RT_plot)
```


```{r RT_lmer}
RT_lmer_data <- filter(acc_data, correct) 
cor_RT_lmm <- mixed(logRT ~ group*condition + (condition|subject),
                    method = "KR",
                    data = RT_lmer_data,
                    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
                    )
cor_RT_lmm_summary <- summary(cor_RT_lmm$full_model, ddf="Kenward-Roger")

emm_options(pbkrtest.limit = 6000)
RT_emm <- emmeans(cor_RT_lmm , specs = c("group", "condition"))
RT_contrasts <- summary(contrast(RT_emm, method = my_contrasts.emmc, by ="group",
                                  adjust = 'holm')
                         )

knitr::kable(nice(cor_RT_lmm), format = 'html') %>%
  kableExtra::kable_styling(full_width = FALSE, position = 'float_left')

select(as.data.frame(RT_contrasts), group, contrast, estimate:p.value) %>%
knitr::kable(format = 'html', align = 'crccccc', digits = c(0,0,3,3,3,3,4),
             caption = paste(attr(RT_contrasts,"mesg"), collapse = ". ")) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::collapse_rows(columns = 1)
```


```{r rstan_RT_glmer}
RT_lmer_uninformed <- stan_lmer(logRT ~ group*condition + (condition|subject),
                                data = RT_lmer_data,
                                seed = 123)

RT_lmer_uninformed_EMM <- emmeans(RT_lmer_uninformed, ~ group * condition)
RT_lmer_uninformed_contrasts <- contrast(RT_lmer_uninformed_EMM, 'my_contrasts',
                                         by = "group")

plot(RT_lmer_uninformed_contrasts) + geom_vline(xintercept = 0)
```

# Questions
- Are differences between semantic-associate retrieval pratice and semantic-associate restudy due to retrieving the wrong thing, e.g., a *different* semantic associate?
